#include "PreCompile.h"
#include <GameEngineCore/GameEngineState.h>

#include "Player.h"
#include "UI_Mouse.h"


void Player::FSM_Player_Idle()
{
	CreateStateParameter PlayerState_Idle_Param;

	PlayerState_Idle_Param.Start = [=](class GameEngineState* _Parent)
	{
		MainSpriteRenderer->ChangeAnimation("Idle");
	};

	PlayerState_Idle_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		// Idle 상태인 동안에는 중력이 작용합니다.
		Gravity(_Delta);
		DirCheck();

		float4 MovePos = float4::ZERO;
		float4 CheckPos = float4::ZERO;

		// <위로 가는 키를 눌렀을 때>
		// 위로 가는 키를 누르면 Jump 상태에 진입합니다.
		if (GameEngineInput::IsDown('W', this))
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Jump);
			return;
		}

		// <아래로 가는 키를 눌렀을 때>
		// 아래 키를 누르는 동안은 PreCrouch 상태에 진입하거나,
		// 바로 아래쪽 픽셀을 검사해 색깔이 푸른색은 경우에는 Fall 상태로 진입합니다.
		if (GameEngineInput::IsDown('S', this))
		{
			CheckPos = { Transform.GetWorldPosition() + DownCheck };
			MovePos = { 0.0f, -Speed * _Delta };

			GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);

			if (Color == GameEngineColor::WHITE || Color == GameEngineColor::BLUE)
			{
				Transform.AddLocalPosition(MovePos);
				FSM_PlayerState.ChangeState(FSM_PlayerState::Fall);
				return;
			}

			// 허공인 하얀색도 아니고, 아래로 이동이 가능한 파란색도 아니라면 (기본적으로 빨강일 것)
			else
			{
				// 숙이기가 기본이고, 구르기로 전환이 가능해지는 PreCrouch 상태로 변환하고 리턴합니다.
				FSM_PlayerState.ChangeState(FSM_PlayerState::PreCrouch);
				return;
			}
		}

		// 왼쪽 혹은 오른쪽 이동 버튼을 누르면 이동(Run) 상태로 변환하고 리턴합니다.
		if (GameEngineInput::IsDown('A', this) || GameEngineInput::IsDown('D', this))
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Run);
			return;
		}

		// 오른쪽 마우스 버튼을 누르면 대쉬 상태로 변환하고 리턴합니다.
		if (GameEngineInput::IsDown(VK_RBUTTON, this))
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Dash);
			return;
		}
	};

	FSM_PlayerState.CreateState(FSM_PlayerState::Idle, PlayerState_Idle_Param);

}

void Player::FSM_Player_Jump()
{
	CreateStateParameter PlayerState_Jump_Param;

	PlayerState_Jump_Param.Start = [=](class GameEngineState* _Parent)
	{
		MainSpriteRenderer->ChangeAnimation("Jump");
	};

	PlayerState_Jump_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		Gravity(_Delta);

		//Speed = 300.0f;
		float4 MovePos = float4::ZERO;
		float4 CheckPos = float4::ZERO;

		//static float JumpTime = 0.0f;

		//JumpTime += _Delta;

		//if (JumpTime > 2.0f)
		//{
		//	FSM_PlayerState.ChangeState(FSM_PlayerState::Fall);
		//	JumpTime = 0.0f;
		//	return;
		//}
		//else
		//{
		CheckPos = { Transform.GetWorldPosition() + UpCheck };
		MovePos = { 0.0f, float4::UP.Y * Speed * _Delta };

		if (GameEngineInput::IsPress('D', this))
		{
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + RightCheck + UpCheck };
			MovePos = { (float4::RIGHT + float4::UP) * Speed * _Delta };
		}

		else if (GameEngineInput::IsPress('A', this))
		{
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + LeftCheck + UpCheck };
			MovePos = { (float4::LEFT + float4::UP) * Speed * _Delta };
		}

		GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);

		if (Color == GameEngineColor::WHITE || Color == GameEngineColor::BLUE)
		{
			Transform.AddLocalPosition(MovePos);
		}

		else
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Fall);
			return;
		}

		// 이전 테스트 값은 -100.0f
		if (GetGravityVector().Y <= -200.0f)
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Fall);
			return;
		}

	};

	FSM_PlayerState.CreateState(FSM_PlayerState::Jump, PlayerState_Jump_Param);
}

void Player::FSM_Player_PreCrouch()
{
	CreateStateParameter PlayerState_PreCrouch_Param;

	PlayerState_PreCrouch_Param.Start = [=](class GameEngineState* _Parent)
	{
		MainSpriteRenderer->ChangeAnimation("PreCrouch");
	};

	PlayerState_PreCrouch_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		// PreCrouch 상태인 동안에는 중력이 작용합니다.
		Gravity(_Delta);
		DirCheck();

		// PreCrouch 상태에서 옆으로 가는 방향키를 누르면 구르기(Roll) 상태로 전환합니다.
		if (GameEngineInput::IsDown('D', this) || GameEngineInput::IsDown('A', this))
		{
			FSM_PlayerState.ChangeState(FSM_PlayerState::Roll);
			return;
		}

	};

	FSM_PlayerState.CreateState(FSM_PlayerState::PreCrouch, PlayerState_PreCrouch_Param);
}

// ★ 구르기를 할 때 Dust 발생
void Player::FSM_Player_Roll()
{
	CreateStateParameter PlayerState_Roll_Param;

	PlayerState_Roll_Param.Start = [=](class GameEngineState* _Parent)
	{
		MainSpriteRenderer->ChangeAnimation("Roll");
	};

	PlayerState_Roll_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		// PreCrouch 상태인 동안에는 중력이 작용합니다.
		Gravity(_Delta);
		DirCheck();

		float4 MovePos = float4::ZERO;
		float4 CheckPos = float4::ZERO;

		// 구르기를 하는 동안 속도는 평소보다 약간 더 빨라집니다. 기본값 : 300
		// ★ 변수를 상수로 할당하지 말고 따로 저장해서 할당할 것
		Speed = 500.0f;

		if (float4::LEFT == Player::MainPlayer->GetPlayerDir())
		{
			CheckPos = { Transform.GetWorldPosition() + LeftCheck };
			MovePos = { float4::LEFT * _Delta * Speed };
		}

		else if (float4::RIGHT == Player::MainPlayer->GetPlayerDir())
		{
			CheckPos = { Transform.GetWorldPosition() + RightCheck };
			MovePos = { float4::RIGHT * _Delta * Speed };
		}

		GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);

		if (Color == GameEngineColor::WHITE)
		{
			Transform.AddWorldPosition(MovePos);
		}

		// 구르기 모션이 끝나면
		if (GetMainRenderer()->IsCurAnimationEnd())
		{
			// 속도를 원래대로 낮춰줍니다.
			Speed = 300.0f;

			// Idle 상태로 전환합니다.
			FSM_PlayerState.ChangeState(FSM_PlayerState::Idle);
			return;
		}

	};

	FSM_PlayerState.CreateState(FSM_PlayerState::Roll, PlayerState_Roll_Param);
}

void Player::FSM_Player_Fall()
{
	CreateStateParameter PlayerState_Fall_Param;

	PlayerState_Fall_Param.Start = [=](class GameEngineState* _Parent)
	{
		MainSpriteRenderer->ChangeAnimation("Fall");
	};

	PlayerState_Fall_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		// PreCrouch 상태인 동안에는 중력이 작용합니다.
		Gravity(_Delta);
		DirCheck();

		float4 MovePos = float4::ZERO;
		float4 CheckPos = float4::ZERO;

		if (GameEngineInput::IsPress('D', this))
		{
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + RightCheck + DownCheck };
			MovePos = { (float4::RIGHT + float4::DOWN) * 200.0f * _Delta };

			//			SetGravityVector((float4::DOWN + float4::RIGHT) * 200.0f);
		}

		else if (GameEngineInput::IsPress('A', this))
		{
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + LeftCheck + DownCheck };
			MovePos = { (float4::LEFT + float4::DOWN) * 200.0f * _Delta };
			//			SetGravityVector((float4::DOWN + float4::LEFT) * 200.0f.0f);
		}

		GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);

		if (Color != GameEngineColor::RED)
		{
			Transform.AddLocalPosition(MovePos);
		}


		if (false == GetGroundPixelCollision())
		{
			PlayerFXRenderer->ChangeAnimation("LandCloud");
			PlayerFXRenderer->Transform.SetLocalPosition({ 0.0f, -24.0f, 0.0f, 1.0f });
			PlayerFXRenderer->On();

			FxPlayer = GameEngineSound::SoundPlay("sound_player_land.wav");

			if (true == PlayerFXRenderer->IsCurAnimationEnd())
			{

				PlayerFXRenderer->Off();
			}

			FSM_PlayerState.ChangeState(FSM_PlayerState::Idle);
			//FSM_PlayerState.ChangeState(FSM_PlayerState::PostCrouch);
			return;
		}

	};

	FSM_PlayerState.CreateState(FSM_PlayerState::Fall, PlayerState_Fall_Param);
}

void Player::FSM_Player_Run()
{
	CreateStateParameter PlayerState_Run_Param;

	PlayerState_Run_Param.Start = [=](class GameEngineState* _Parent)
	{
		FxPlayer = GameEngineSound::SoundPlay("sound_player_running_1.wav");
		MainSpriteRenderer->ChangeAnimation("Run");
	};

	PlayerState_Run_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		Gravity(_Delta);

		DirCheck();

		//if (true == GetGroundPixelCollision())
		//{
		//	PlayerFXRenderer->Off();
		//	ChangeState(PlayerState::Fall);
		//	return;
		//}

		if (GameEngineInput::IsPress('W', this))
		{
			DirCheck();
			FSM_PlayerState.ChangeState(FSM_PlayerState::Jump);
			return;
		}

		float4 MovePos = float4::ZERO;
		float4 CheckPos = float4::ZERO;

		PlayerFXRenderer->On();
		PlayerFXRenderer->ChangeAnimation("RunCloud");

		//if (Dir == PlayerDir::Left)
		//{
		//	PlayerFXRenderer->Transform.SetLocalPosition({ 20.0f, -20.0f, 0.0f, 1.0f });
		//}

		//else if (Dir == PlayerDir::Right)
		//{
		//	PlayerFXRenderer->Transform.SetLocalPosition({ -20.0f, -20.0f, 0.0f, 1.0f });
		//}


		if (GameEngineInput::IsPress('A', this))
		{
			Gravity(_Delta);
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + LeftCheck };
			MovePos = { float4::LEFT * _Delta * Speed };
		}

		if (GameEngineInput::IsPress('D', this))
		{
			Gravity(_Delta);
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + RightCheck };
			MovePos = { float4::RIGHT * _Delta * Speed };
		}

		if (GameEngineInput::IsPress('S', this))
		{
			DirCheck();
			CheckPos = { Transform.GetWorldPosition() + DownCheck };

			GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);

			if (Color == GameEngineColor::RED)
			{
				FSM_PlayerState.ChangeState(FSM_PlayerState::PreCrouch);
				return;
			}

			MovePos = { float4::DOWN * Speed * _Delta };
		}

		if (GameEngineInput::IsDown(VK_LBUTTON, this))
		{
			PlayerFXRenderer->Off();
			//	FSM_PlayerState.ChangeState(FSM_PlayerState::Attack);
			return;
		}

		// 더 이상 입력이 없으면 멈춘 것으로 간주하고 Idle 상태로 변환 후 리턴합니다.
		if (MovePos == float4::ZERO)
		{
			DirCheck();
			PlayerFXRenderer->Off();
			FSM_PlayerState.ChangeState(FSM_PlayerState::Idle);
			return;
		}



		GameEngineColor Color = GetMapColor(CheckPos, GameEngineColor::WHITE);


		if (Color == GameEngineColor::WHITE || Color == GameEngineColor::BLUE)
		{
			Transform.AddWorldPosition(MovePos);
		}




	};

	FSM_PlayerState.CreateState(FSM_PlayerState::Run, PlayerState_Run_Param);


}

void Player::FSM_Player_Dash()
{
	CreateStateParameter PlayerState_Dash_Param;

	PlayerState_Dash_Param.Start = [=](class GameEngineState* _Parent)
	{
		IsOnDash = true;
		PlayerRenderer_Dash->On();
	};

	PlayerState_Dash_Param.Stay = [=](float _Delta, class GameEngineState* _Parent)
	{
		// Dash 상태인 동안 중력, 방향 설정이 작용합니다.
		Gravity(_Delta);
		DirCheck();

		// 위치 계산을 위한 변수 값 지정
		float4 PlayerPos = Player::MainPlayer->Transform.GetWorldPosition();
		MousePos = GetLevel()->GetMainCamera()->GetWorldMousePos2D();

		// 클릭한 위치를 계산합니다.
		float4 PlayerNextPos = UI_Mouse::Mouse->GetMouseWorldToActorPos() - PlayerPos;

		// 대쉬 라인이 비활성 상태면 활성화하여 화면에 보이도록 합니다.
		if (false == PlayerRenderer_DashLine->GetUpdateValue())
		{
			PlayerRenderer_DashLine->On();
		}

		// 라인 범위 계산
		float4 RenderLinePos = PlayerRenderer_DashLine->Transform.GetLocalPosition();
		float4 MouseCheckPos = MousePos - RenderLinePos;

		float4 angle = atan2(MousePos.Y - RenderLinePos.Y,
			MousePos.X - RenderLinePos.X * GameEngineMath::R2D);

		// 디버그용
		OutputDebugStringA(angle.ToString("\n").c_str());

		ToMouse = MousePos - PlayerPos;
		ToMouse.Size();

		float4 t = ToMouse;

		//	이동 범위가 max range = 200.0f, min range = -200.0f 를 벗어나지 않도록 보간합니다.
		if (t.X > 200.0f)
		{
			t.X = 200.0f;
		}

		if (t.X < -200.0f)
		{
			t.X = -200.0f;
		}

		else if (t.Y > 200.0f)
		{
			t.Y = 200.0f;
		}

		if (t.Y < -200.0f)
		{
			t.Y = -200.0f;
		}

		ToMouse.Normalize();
		ToMouse.X = abs(ToMouse.X);
		ToMouse.Y = abs(ToMouse.Y);

		ToMouse *= t;

		// 위에서 계산한 값에 맞춰 라인을 출력합니다.
		PlayerRenderer_DashLine->SetPivotType(PivotType::Left);
		PlayerRenderer_DashLine->Transform.SetLocalScale({ ToMouse.X / 3.0f, 2.0f, 1.0f });

		PlayerRenderer_DashLine->Transform.AddLocalRotation({ 0.0f, 0.0f, 1.0f });


		// 버튼을 떼고 있는 동안 이동 지점이 유효한지 확인한 뒤,
		// 앞서 계산된 위치로 플레이어가 이동합니다.
		if (true == GameEngineInput::IsFree(VK_RBUTTON, this))
		{
			while (true == Player::MainPlayer->IsOnDash)
			{
				GameEngineColor ColorCheck = 
					Player::MainPlayer->GetMapColor(PlayerNextPos, GameEngineColor::WHITE);

			//	UI_Mouse::Mouse->MouseCollision->Transform.SetLocalPosition(PlayerNextPos);

				if (ColorCheck != GameEngineColor::WHITE)
				{
					IsOnDash = false;
				}
				else
				{
					MainSpriteRenderer->ChangeAnimation("Dash");
					Player::MainPlayer->Transform.AddLocalPosition(ToMouse);
					Player::MainPlayer->IsOnDash = false;
				}
			}


			// 화면에 출력되고 있는 대쉬 범위, 라인 렌더러 비활성화
			if (true == PlayerRenderer_DashLine->GetUpdateValue())
			{
				PlayerRenderer_DashLine->Off();
			}

			PlayerRenderer_Dash->Off();


			// 대쉬 애니메이션이 끝나면 Idle 상태로 전환합니다.
			if (Player::MainPlayer->GetMainRenderer()->IsCurAnimationEnd())
			{
				FSM_PlayerState.ChangeState(FSM_PlayerState::Idle);
				return;
			}

		}

	};

	/*
	    <추후 보강해야 하는 기능>
		1. 대쉬 이동 중에 충돌한 몬스터가 있는 경우 데미지를 줘야 함
		2. 대쉬 이동이 끝나면 쿨타임 타이머가 작동하며, 쿨타임 동안 다시 대쉬 상태에 진입할 수 없음
	*/

	FSM_PlayerState.CreateState(FSM_PlayerState::Dash, PlayerState_Dash_Param);
}